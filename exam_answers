1.
    A.  Alice sends Bob A = 573450335
        Bob's secret number = 544097
        Bob sends Alice B = 337242414
        The private key is : 
        661737200

    B.  419341648852474208

2.  
    A.  1 - get inv modulo of the key and alphabet length:
                inverse of (key)mod(a.size) is the value b < a.len where
                ((key * x) % a.len == 1)
        2 - use the inv modulo as the "new key":
            for every letter -> new letter is alphabet.index(letter)*nkey)%a.size
    
    B.  IDONTKNOWRICKITLOOKSFAKE -> QGCAMUACSIQEUQMWCCUKKAUI
        QGCAMUACSIQEUQMWCCUKKAUI -> QGCAMUACSIQEUQMWCCUKKAUI

        The multiplicative inverse of “a modulo m” exists only if a and m are relatively prime,
        that means that the gcd of "a" and "b" must be 1. In this case, 2 and 26 have a gcd of 2
        so the inverse doesn't exist and the text can't be decrypted

3.  
    A.  
        CPXBAAWCAN Key: 5 -> XKSWVVRXVI != IVXRVVWSKX 
        AXRWQXLLRGXGCGENJSMHDP Key: 5 -> VSMRLSGGMBSBXBZIENHCYK != VSMRSLGGMBRBXBZIENHCYY

    B.  THEYREHERE
        MAXIMUSDECIMUSMERIDIUS

4.
    A.  Hexadecimal alphabet = {'0123456789ABCDEF'} len(Alphabet) = 16 len(Ciphertext) = 20
        Worst-case scenario takes place when the length of the key equals the length of the plaintext
        so len(key) = len(Ciphertext) 
        keys = number of choices in alphabet ^  number of choices in key which is len(key)
        keys = 16^20 = 1.208925819614629174706176 × 10^24 keys

    B.  Worst-case scenario, the last key analyzed is the correct key
        so Time = (1.208925819614629174706176 × 10^24) * 0.15ms
        Time = 1.813×10^23 ms
        according to wolfram, that's about 5.746×10^12 average Gregorian years

    C.  