1.
    A.  Alice sends Bob A = 573450335
        Bob's secret number = 544097
        Bob sends Alice B = 337242414
        The private key is : 
        661737200

        >> Comment: The answer is correct.

    B.  033040811485173401

        >> Comment: The answer is correct.

2.  
    A.  1 - get inv modulo of the key and alphabet length:
                inverse of (key)mod(a.size) is the value b < a.len where
                ((key * x) % a.len == 1)
        2 - use the inv modulo as the "new key":
            for every letter -> new letter is alphabet.index(letter)*nkey)%a.size

        >> Comment: The answer points towards the right direction, but you didn't decrypt the message. The answer requires a step by step example.
    
    B.  IDONTKNOWRICKITLOOKSFAKE -> QGCAMUACSIQEUQMWCCUKKAUI
        QGCAMUACSIQEUQMWCCUKKAUI -> QGCAMUACSIQEUQMWCCUKKAUI

        The multiplicative inverse of “a modulo m” exists only if a and m are relatively prime,
        that means that the gcd of "a" and "b" must be 1. In this case, 2 and 26 have a gcd of 2
        so the inverse doesn't exist and the text can't be decrypted

        >> Comment: The answer is correct. However, please note that you can use 2 as the key and will retrieve something. It is not going to be the correct plaintext, but some parts of it. What it will not be is the same string given as input. Then, QGCAMUACSIQEUQMWCCUKKAUI -> QGCAMUACSIQEUQMWCCUKKAUI is not correct (but not completely wrong).

3.  
    A.  
        IVXRVVWSKX Key: 5 -> NACWAABXPC != CPXBAAWCAN 
        VSMRSLGGMBRBXBZIENHCYY Key: 5 -> AXRWXQLLRGWGCGENJSMHDD != AXRWQXLLRGXGCGENJSMHDP

        >> Comment: Correct, but it was luck. You need to apply the shift cipher on the ciphertext to produce the MAC. If the MAC you obtain is different to the one you receive, then the message has been altered. What you did was to decrypt the MAC by using the shift cipher with a key of 5. Please note that this may not always work since it depends on the MAC function. Change it before you submit the final solution.

    B.  YOUCOMPLETEME
        MAXIMUSDECIMUSMERIDIUS

        >> Comment: 1/2 Correct. One of the plaintext corresponds to a ciphertext that was altered. Revise this solution.

4.
    A.  Hexadecimal alphabet = {'0123456789ABCDEF'} len(Alphabet) = 16 len(Ciphertext) = 20
        Worst-case scenario takes place when the length of the key equals the length of the plaintext
        so len(key) = len(Ciphertext) 
        keys = number of choices in alphabet ^  number of choices in key which is len(key)
        keys = 16^20 = 1.208925819614629174706176 × 10^24 keys

        >> Comment: Correct.

    B.  Worst-case scenario, the last key analyzed is the correct key
        so Time = (1.208925819614629174706176 × 10^24) * 0.15ms
        Time = 1.813×10^23 ms
        according to wolfram, that's about 5.746×10^12 average Gregorian years

        >> Comment: Correct.

    C.  If you convert Hexadecimal to binary, for every letter you will have 4 binary digits
        meaning the key length changes to 20 letters * 4 digits = 80 digits.
        However, 80 digits with 2 choices {0,1} are 2^80 = 1.208925819614629174706176 × 10^24 keys
        which is the same as keeping it in hexadecimal

        >> Comment: Correct.

5.  A.  On systems with limited capabilities to execute logic or bitwise operations. Also AND is potentially and irreversible operation and might not be appropriate for
        encryption.

        >> Comment: I would consider this answer correct. However, the truth is that this version of the cipher is not even a cipher. Once you AND two bits, and the result is false, there is no way to get back the plaintext, since there are three valid values to choose from. Then, this strategy does not work at all.    

    B.  It has worse security than the XOR version since it is more likely to have unflipped bits and could potentially show the information partially, which may make it easier to interpet.

        >> Comment: Kind of correct. Although it does not work for the reasons I previously mentioned, it is clear that, for the cases where it works, it will surely leave some patterns that will make it vulnerable.

    C.  It is not a safer option.

        >> Comment: Correct. It is no even a valid option.

6.  A.  If key size is k, there can be 2^k.

    B.  If the key length is 10, the number of combinations is 2^10.

    C.  It is the same as in the one-time pad cipher, 2^10. Based on the formula defined in A.

    D.  Because we are using binary, it produces the same degree of security as the one-time pad cipher (the safest encryption) so we can 
        argue that permutation cipher is safe in this case.

7.  A.  We can decipher the key bits with the exposed plaintext using XOR to reverse the operation bit by bit. Using this we know so far that the key is 
        1-01. To obtain the second bit in the key, we would need to reverse the operation with XOR using another plaintext but we don't have it. If we had a
        complete english alphabet, we could maybe interpret the word using the human understanding of language. Since we are talking about bits, we cannot guess
        what the answer is. 

8.  A.  The encrypted message for Alice is: 343231970106150475720500
    B.  Bob's public key would be 576186617609 using a generator (rsa.java). Private key is 375847428473.   