1.
    A.  Alice sends Bob A = 573450335
        Bob's secret number = 544097
        Bob sends Alice B = 337242414
        The private key is : 
        661737200

    B.  033040811485173401

2.  
    A.  1 - get inv modulo of the key and alphabet length:
                inverse of (key)mod(a.size) is the value b < a.len where
                ((key * x) % a.len == 1)
        2 - use the inv modulo as the "new key":
            for every letter -> new letter is alphabet.index(letter)*nkey)%a.size
    
    B.  IDONTKNOWRICKITLOOKSFAKE -> QGCAMUACSIQEUQMWCCUKKAUI
        QGCAMUACSIQEUQMWCCUKKAUI -> QGCAMUACSIQEUQMWCCUKKAUI

        The multiplicative inverse of “a modulo m” exists only if a and m are relatively prime,
        that means that the gcd of "a" and "b" must be 1. In this case, 2 and 26 have a gcd of 2
        so the inverse doesn't exist and the text can't be decrypted

3.  
    A.  
        CPXBAAWCAN Key: 5 -> XKSWVVRXVI != IVXRVVWSKX 
        AXRWQXLLRGXGCGENJSMHDP Key: 5 -> VSMRLSGGMBSBXBZIENHCYK != VSMRSLGGMBRBXBZIENHCYY

    B.  THEYREHERE
        MAXIMUSDECIMUSMERIDIUS

4.
    A.  Hexadecimal alphabet = {'0123456789ABCDEF'} len(Alphabet) = 16 len(Ciphertext) = 20
        Worst-case scenario takes place when the length of the key equals the length of the plaintext
        so len(key) = len(Ciphertext) 
        keys = number of choices in alphabet ^  number of choices in key which is len(key)
        keys = 16^20 = 1.208925819614629174706176 × 10^24 keys

    B.  Worst-case scenario, the last key analyzed is the correct key
        so Time = (1.208925819614629174706176 × 10^24) * 0.15ms
        Time = 1.813×10^23 ms
        according to wolfram, that's about 5.746×10^12 average Gregorian years

    C.  If you convert Hexadecimal to binary, for every letter you will have 4 binary digits
        meaning the key length changes to 20 letters * 4 digits = 80 digits.
        However, 80 digits with 2 choices {0,1} are 2^80 = 1.208925819614629174706176 × 10^24 keys
        which is the same as keeping it in hexadecimal

5.  A. On systems with limited capabilities to execute logic or bitwise operations.
    B. It has worse security than the XOR version since it is more likely to have unflipped bits 
    and could potentially show the information partially, which may make it easier to interpet.
    C. It is not a safer option

    

6.  A.
    B.
    C.
    D.

7.  A.

8.  A.
    B.
    C.

